#
# tmo.racc
# Author: Mike Roda

class Tmo
  options no_result_var

# Racc rules specifying the grammar
#

rule

  program        : lines

  lines          : line lines
                 | line
                 
  line           : TM_DATA TM_INT                 { @output.write val[0] + " " + val[1].to_s + "\n" }
                 | TM_SDATA TM_SLIT               { @output.write val[0] + " " + val[1] + "\n" }
                 | instruction
  
  instruction    : ro_instruction                 { val[0] }
                 | rm_instruction                 { val[0] }

  ro_instruction : TM_INT TM_COLON ro_opcode TM_INT TM_COMMA TM_INT TM_COMMA TM_INT   

                                                  {
                                                   tm = ROInstr.new(val[0], val[2], val[3], val[5], val[7])
                                                   @bblocks[0].cmds[val[0]] = tm
                                                  }
  
                 

  rm_instruction : TM_INT TM_COLON rm_opcode TM_INT TM_COMMA TM_INT TM_LPARENS TM_INT TM_RPARENS

                                                  {
                                                   tm = RMInstr.new(val[0], val[2], val[3], val[5], val[7]) 
                                                   @bblocks[0].cmds[val[0]] = tm
                                                  }

  ro_opcode      : TM_HALT
                 | TM_OUTNL
                 | TM_IN
                 | TM_OUT
                 | TM_INB
                 | TM_OUTB 
                 | TM_OUTC
                 | TM_ADD
                 | TM_SUB
                 | TM_MUL
                 | TM_DIV
                 
  rm_opcode      : TM_LDC
                 | TM_LDA
                 | TM_LD
                 | TM_ST
                 | TM_JLT
                 | TM_JLE
                 | TM_JEQ
                 | TM_JNE
                 | TM_JGE
                 | TM_JGT
                  
end

---- header ----
#
# generated by racc
#
require 'set'
require 'tmo.rex'

---- inner ----

class BasicBlock
  attr_accessor :id
  attr_accessor :cmds
  attr_accessor :connections
  attr_accessor :reachable
  attr_accessor :out
  attr_accessor :in

  @@ids = 0

  def initialize
    @id = @@ids
    @@ids += 1
    @cmds = []
    @connections = []
    @reachable = false
    @out = Set.new
    @in = Set.new
  end
  
  def self.start_over
    @@ids = 0
  end
  
  # split off a new basic block starting from line n and return it
  def split(n, flows_thru = true)
    newblock = BasicBlock.new
    newblock.cmds = @cmds[n..(@cmds.length-1)]

    @cmds = @cmds[0..(n-1)]

    # move the fall-through control flow from the original block to the new block
    newblock.connections = @connections
    newblock.reachable = true if flows_thru
    @connections = []

    # original block will fall-through to the new block
    @connections << newblock if flows_thru

    newblock
  end
end

class TinyMachineInstruction
  attr_accessor :line
  attr_reader :opcode
  
  def initialize(line, opcode)
    @line = line
    @opcode = opcode
  end

  def no_op
    false
  end

  def same_address(obj)
    false
  end  
  
  def to_s
    @line.to_s + ":  " + @opcode
  end
  
  def is_jump
    false
  end

  def is_unconditional_jump
    false
  end
end

class ROInstr < TinyMachineInstruction
  attr_reader :reg_r
  attr_reader :reg_s
  attr_reader :reg_t
  
  def initialize(line, opcode, reg_r, reg_s, reg_t)
    super(line, opcode)
    @reg_r = reg_r
    @reg_s = reg_s
    @reg_t = reg_t
  end

  def ==(obj)
    @opcode == obj.opcode && @reg_r == obj.reg_r && @reg_s == obj.reg_s && @reg_t == obj.reg_t
  end

  def common_subexp(obj)
    (@opcode == "ADD" || @opcode == "SUB" || @opcode == "MUL" || @opcode == "DIV") && @opcode == obj.opcode && @reg_s == obj.reg_s && @reg_t == obj.reg_t
  end
  
  def uses_register(reg)
    (@reg_s == reg || @reg_t == reg) && (@opcode == "ADD" || @opcode == "SUB" || @opcode == "DIV" || @opcode == "MUL") || @reg_r == reg && (@opcode == "OUT" || @opcode == "OUTB" || @opcode == "OUTC") 
  end

  def uses_registers
    if (@opcode == "ADD" || @opcode == "SUB" || @opcode == "DIV" || @opcode == "MUL")
      Set.new.add(@reg_s).add(@reg_t)
    elsif (@opcode == "OUT" || @opcode == "OUTB" || @opcode == "OUTC") 
      Set.new.add(@reg_r)
    else
      Set.new
    end
  end

  def change_register(old_r, new_r)
    if @opcode == "ADD" || @opcode == "SUB" || @opcode == "DIV" || @opcode == "MUL"
      @reg_s = new_r if @reg_s == old_r
      @reg_t = new_r if @reg_t == old_r
    elsif @opcode == "OUT" || @opcode == "OUTB" || @opcode == "OUTC"
      @reg_r = new_r if @reg_r == old_r    
    end
  end
  
  def defines_register
    opcode == "ADD" || opcode == "SUB" || opcode == "MUL" || opcode == "DIV" || opcode == "IN" || opcode == "INB"
  end  
    
  def to_s
    super.to_s() + "  " + @reg_r.to_s + "," + @reg_s.to_s + "," + @reg_t.to_s
  end
end

class RMInstr < TinyMachineInstruction
  attr_reader :reg_r
  attr_accessor :d
  attr_reader :reg_s
  
  def initialize(line, opcode, reg_r, d, reg_s)
    super(line, opcode)
    @reg_r = reg_r
    @d = d
    @reg_s = reg_s
  end
  
  def ==(obj)
    @opcode == obj.opcode && @reg_r == obj.reg_r && @d == obj.d && @reg_s == obj.reg_s
  end

  def same_address(obj)
    @reg_s == 0 && obj.reg_s == 0 && @d == obj.d
  end
  
  def common_subexp(obj)
    (@opcode == "LD" || @opcode == "LDC") && @opcode == obj.opcode && @d == obj.d && @reg_s == obj.reg_s
  end
  
  def defines_register
    opcode == "LDC" || opcode == "LDA" || opcode == "LD"
  end  
  
  def uses_register(reg)
    @reg_s == reg && @opcode != "LDC" || @reg_r == reg && @opcode == "ST"
  end
  
  def uses_registers
    if (@opcode == "LDA" || @opcode == "LD")
      Set.new.add(@reg_s)
    elsif (@opcode == "ST" || @opcode == "JLT" || @opcode == "JLE" || @opcode == "JEQ" || @opcode == "JNE" || @opcode == "JGE" || @opcode == "JGT")
      Set.new.add(@reg_r).add(@reg_s)
    else
      Set.new
    end
  end

  def change_register(old_r, new_r)
    if @opcode == "ST"
      @reg_r = new_r if @reg_r == old_r
    elsif @opcode != "LDC"
      @reg_s = new_r if @reg_s == old_r
    end
  end
  
  def no_op
    @opcode[0,1] == "J" && @d == 0 && @reg_s == 7
  end

  def to_s
    super.to_s() + "  " + @reg_r.to_s + "," + @d.to_s + "(" + @reg_s.to_s + ")"
  end
  
  def is_jump
    if @opcode[0,1] == "J" && @reg_s != 0 && @reg_s != 7
      puts "Line " + @line.to_s + ": Optimizer does not support jump based on dynamic register"
      exit 1
      false
    elsif @opcode == "LD" && @reg_r == 7
      puts "Line " + @line.to_s + ": Optimizer does not support address load to PC from memory"
      exit 1
       false
    elsif @opcode == "LDA" && @reg_r == 7 && @reg_s != 0 && @reg_s != 7
      puts "Line " + @line.to_s + ": Optimizer does not support address load to PC based on dynamic register"
      exit 1
      false
    elsif @opcode[0,1] == "J" || (@reg_r == 7 && (@opcode == "LDA" || @opcode == "LDC"))
      true
    end
  end

  def is_unconditional_jump
    if is_jump && ((@opcode == "JEQ" && @reg_r == 0) || @reg_r == 7 && defines_register)
      true
    else
      false
    end
  end

  def jumps_to
    if (@opcode[0,1] == "J" || @opcode == "LDA") && @reg_s == 7
      @line + 1 + @d
    elsif (@opcode[0,1] == "J" || @opcode == "LDA") && @reg_s == 0
      @d
    elsif @opcode == "LDC"
      @d
    end
  end

  def adjust_jump(offset)
    @d += offset
  end
end

attr_accessor :bblocks
attr_accessor :output

def initialize
  super
  @lineno  =  1
  @bblocks = Array.new
  bb = BasicBlock.new
  bb.reachable = true
  @bblocks << bb
end

---- footer ----

output = nil
if ARGV.size == 1
  filename = ARGV.shift
  output = File.new(filename, "w")
end

tmo = Tmo.new
tmo.output = output

tmo.read_stdin

begin
  tmo.parse
  
rescue Tmo::ScanError
    puts 'line ' + tmo.lineno.to_s + ': illegal character (' + tmo.token + ')'
    exit 1
rescue ParseError
    puts 'line ' + tmo.lineno.to_s + ': syntax error near ' + tmo.token
    exit 1
end

keep_optimizing = true
main_pass = 1

while keep_optimizing

print "\n"
puts "Pass " + main_pass.to_s

bb = tmo.bblocks[0]
num_instructions = bb.cmds.length

print "\n"
puts "Performing jump chain optimization"

made_optimization = true
while made_optimization
  made_optimization = false
  for n in 0..(bb.cmds.length-1)
    cmd = bb.cmds[n]
    if cmd.is_jump
      jump_to_line = cmd.jumps_to

      for cmd2 in bb.cmds
        if cmd2.line == jump_to_line
          if cmd2.is_unconditional_jump
            ultimate_jump_to_line = cmd2.jumps_to
            offset = ultimate_jump_to_line - jump_to_line
            puts "  Adjusting jump on line " + cmd.line.to_s + " by " + offset.to_s + " lines"
            cmd.adjust_jump(offset)
            made_optimization = true
          end
          break
        end
      end
    end
  end
end

print "\n"
puts "Performing control-flow analysis"
puts "  Splitting blocks at location of jumps"
n = -1

while n < (bb.cmds.length - 1)
  n += 1
  cmd = bb.cmds[n]
      
  if cmd.is_jump
    jump_to_line = cmd.jumps_to

    if (n < bb.cmds.length - 1)
      # if jump isn't the last instruction in the block, split it
      puts "    Block " + bb.id.to_s + " line " + cmd.line.to_s + ", jumps to line " + jump_to_line.to_s

      flows_thru = !((cmd.reg_r == 0 && (cmd.opcode == "JEQ" || cmd.opcode == "JLE" || cmd.opcode == "JGE")) || (cmd.opcode == "LDC" || cmd.opcode == "LD" || cmd.opcode == "LDA"))
      newblock = bb.split(n + 1, flows_thru)
      tmo.bblocks.insert(bb.id + 1, newblock)

      # start scanning the new block
      bb = newblock
      n = -1
    end
  end
end

print "\n"
puts "  Splitting blocks at destination of jumps"

split = true

while split

  split = false
  
  for b in 0..(tmo.bblocks.length-1)
    bb = tmo.bblocks[b]

    for cmd in bb.cmds
      
      if cmd.is_jump
        jump_to_line = cmd.jumps_to

        # find the block with this line in it and split it if necessary
        found = false
        for b2 in 0..(tmo.bblocks.length-1)
          bb2 = tmo.bblocks[b2]
          for m in 0..(bb2.cmds.length - 1)
            if bb2.cmds[m].line == jump_to_line
              found = true
              if m > 0
                puts "    Block " + bb2.id.to_s + " line " + bb2.cmds[m].line.to_s + ", destination from jump on line " + cmd.line.to_s + " in block " + bb.id.to_s
                # destination isn't the first instruction in the block, split it
                newblock = bb2.split(m)
                tmo.bblocks.insert(b2 + 1, newblock)
                split = true
                break
              end
            end
          end
          break if found
        end
      end

      break if split
    end
    
    break if split     # break out of the loop through basic blocks
  end
end

print "\n"
puts "Determine the control flow between blocks"

for b in 0..(tmo.bblocks.length-1)
  bb = tmo.bblocks[b]
  for cmd in bb.cmds
    if cmd.is_jump
      jump_to_line = cmd.jumps_to

      # find the block with this line in it and connect them
      found = false
      for bb2 in tmo.bblocks
        for cmd2 in bb2.cmds
          if cmd2.line == jump_to_line
            if bb != bb2
              bb.connections << bb2
              bb2.reachable = true
            end
            found = true
          end
        end
        break if found
      end
      puts "Warning: cannot find block with line " + cmd.line.to_s if !found
    end
  end
end

# output the control-flow information
if true
for b in 0..(tmo.bblocks.length - 1)
  bb = tmo.bblocks[b]
  if bb.cmds.length == 0
    print "    Block #" + bb.id.to_s + " no lines!"
  else
    print "    Block #" + bb.id.to_s + " line(s) " + bb.cmds[0].line.to_s
    print "-" + bb.cmds.last.line.to_s if bb.cmds.length > 1
  end
  
  print " -> Block(s) #" if bb.connections.length > 0
  for c in 0..(bb.connections.length-1)
    print "," if c > 0
    print bb.connections[c].id.to_s
  end
  
  print "\n"
end
end

print "\n"
puts "Live variable data-flow analysis"
changes_to_in_occurred = true
pass = 1
while changes_to_in_occurred
#  puts " Pass " + pass.to_s
  changes_to_in_occurred = false
  for bb in tmo.bblocks
    num_in  = bb.in.length

    bb.connections.each {|bb2| bb.out.merge(bb2.in) }
  
    # calculate the {def} and {use} sets for this block
    defB = Set.new
    useB = Set.new
    for cmd in bb.cmds
      cmd.uses_registers.each {|r| useB.add(r) if !defB.include?(r)}
      defB.add(cmd.reg_r) if cmd.defines_register && !useB.include?(cmd.reg_r)
    end
    
    bb.in = useB.union(bb.out - defB)
    
    changes_to_in_occurred = true if num_in != bb.in.length
  end
  pass += 1
end
if false
for bb in tmo.bblocks
  print "  Basic block #" + bb.id.to_s

  print " IN = {"
  bb.in.each {|r| print r.to_s + " "}
  print "} OUT = {"
  bb.out.each {|r| print r.to_s + " "}
  print "}\n"
end
end

print "\n"
puts "Common subexpression and copy propegation"

made_optimization = true
pass = 1
while made_optimization
  made_optimization = false

  for bb in tmo.bblocks
#    puts " Pass " + pass.to_s + ", block #" + bb.id.to_s
    subexpressions = Array.new(8)

    for n in 0..(bb.cmds.length-1)
      cmd = bb.cmds[n]
      
      # check if this command redefines register or memory address used by an earlier subexpression
      if cmd.opcode == "ST" || cmd.defines_register
        for r in 0..7
          if !subexpressions[r].nil? && 
             (cmd.opcode == "ST" && subexpressions[r].opcode == "LD" && subexpressions[r].same_address(cmd) ||
              cmd.defines_register && subexpressions[r].uses_register(cmd.reg_r))
#            puts "  Line " + cmd.line.to_s + " eliminates re-use of subexpression on line " + subexpressions[r].line.to_s
            subexpressions[r] = nil
          end
        end
      end
      
      # now look for common subexpressions
      case cmd.opcode
        when "LD", "ADD", "SUB", "MUL", "DIV", "LDC"
          # look for another register with a common subexpression
          found = false
          for r in 0..7
            if !subexpressions[r].nil? && subexpressions[r].reg_r != cmd.reg_r && subexpressions[r].common_subexp(cmd)
              puts "* Changing line " + cmd.line.to_s + ", using common subexpression from line " + subexpressions[r].line.to_s
              # replace the instruction with a move
              bb.cmds[n] = Tmo::RMInstr.new(cmd.line, "LDA", cmd.reg_r, 0, subexpressions[r].reg_r)
              made_optimization = true
              found = true
              break
            end
          end
          
        
          if !found
            subexpressions[cmd.reg_r] = cmd
          end

        when "LDA", "IN", "INB"
          subexpressions[cmd.reg_r] = nil
        end

      # copy propagation
#      puts "  Line " + cmd.line.to_s + ": Register " + cmd.reg_r.to_s + " is live leaving block " + bb.id.to_s + ", copy propagation not possible"
      
      if cmd.opcode == "LDA" && cmd.reg_r != cmd.reg_s && cmd.d == 0 && !bb.out.include?(cmd.reg_r)

        # pre-check remaining instructions for eligibility for copy propagation
        copy_propagation_eligible = true
        reg_s_redefined = false

        for m in (n+1)..(bb.cmds.length-1)
          cmd2 = bb.cmds[m]
          
          # stop searching once reg_r is redefined or reach end of block
          break if cmd2.defines_register && cmd2.reg_r == cmd.reg_r
          
          if cmd2.uses_register(cmd.reg_r) && reg_s_redefined
            copy_propagation_eligible = false
            break
          end
          
          if cmd2.defines_register && cmd2.reg_r == cmd.reg_s
            reg_s_redefined = true
          end
        end
        
        # now perform the optimizations
        if copy_propagation_eligible
          for m in (n+1)..(bb.cmds.length-1)
            cmd2 = bb.cmds[m]
          
            # stop searching once reg_r is redefined or reach end of block
            break if cmd2.defines_register && cmd2.reg_r == cmd.reg_r
          
            if cmd2.uses_register(cmd.reg_r)
              puts "* Changing register on line " + cmd2.line.to_s
              cmd2.change_register(cmd.reg_r, cmd.reg_s)
            end
          end
          
          puts "* Changing line " + cmd.line.to_s + " to no-op"
          bb.cmds[n] = Tmo::RMInstr.new(cmd.line, "LDA", 0, 0, 0)
        end
      end
    end
  end
  pass += 1
end

print "\n"
puts "Performing constant propegation"
 
made_optimization = true
pass = 1
while made_optimization
  made_optimization = false

  for bb in tmo.bblocks
    constants = Array.new(8)

    for n in 0..(bb.cmds.length-1)
      cmd = bb.cmds[n]
      
      next if cmd.defines_register && cmd.reg_r == 7
      
      if cmd.opcode == "LDC"
        # save constant value of register
        constants[cmd.reg_r] = cmd.d
        next
      end
      
      if cmd.opcode == "ADD" && !constants[cmd.reg_s].nil? && !constants[cmd.reg_t].nil? 
        puts "* Changing ADD on line " + cmd.line.to_s + " to LDC"
        bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDC", cmd.reg_r, constants[cmd.reg_s] + constants[cmd.reg_t], 0)
        made_optimization = true
        constants[cmd.reg_r] = constants[cmd.reg_s] + constants[cmd.reg_t]
      elsif cmd.opcode == "ADD" && !constants[cmd.reg_s].nil? 
        puts "* Changing ADD on line " + cmd.line.to_s + " to LDA"
        bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", cmd.reg_r, constants[cmd.reg_s], cmd.reg_t)
        made_optimization = true
      elsif cmd.opcode == "ADD" && !constants[cmd.reg_t].nil? 
        puts "* Changing ADD on line " + cmd.line.to_s + " to LDA"
        bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", cmd.reg_r, constants[cmd.reg_t], cmd.reg_s)
        made_optimization = true
      elsif cmd.opcode == "SUB" && !constants[cmd.reg_s].nil? && !constants[cmd.reg_t].nil? 
        puts "* Changing SUB on line " + cmd.line.to_s + " to LDC"
        bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDC", cmd.reg_r, constants[cmd.reg_s] - constants[cmd.reg_t], 0)
        made_optimization = true
        constants[cmd.reg_r] = constants[cmd.reg_s] - constants[cmd.reg_t]
      elsif cmd.opcode == "SUB" && !constants[cmd.reg_t].nil? 
        puts "* Changing SUB on line " + cmd.line.to_s + " to LDA"
        bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", cmd.reg_r, constants[cmd.reg_t] * -1, cmd.reg_s)
        made_optimization = true
      elsif cmd.opcode == "MUL" && !constants[cmd.reg_s].nil? && !constants[cmd.reg_t].nil? 
        puts "* Changing MUL on line " + cmd.line.to_s + " to LDC"
        bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDC", cmd.reg_r, constants[cmd.reg_s] * constants[cmd.reg_t], 0)
        made_optimization = true
        constants[cmd.reg_r] = constants[cmd.reg_s] * constants[cmd.reg_t]
      elsif cmd.opcode == "LDA" && !constants[cmd.reg_s].nil? 
        puts "* Changing LDA on line " + cmd.line.to_s + " to LDC"
        bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDC", cmd.reg_r, constants[cmd.reg_s] + cmd.d, 0)
        made_optimization = true
        constants[cmd.reg_r] = constants[cmd.reg_s] + cmd.d
      elsif cmd.opcode == "JEQ" && !constants[cmd.reg_r].nil?
        if constants[cmd.reg_r] == 0
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to LDA"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 7, cmd.d, cmd.reg_s)
        else
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to no-op"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 0, 0, 0)
        end
        made_optimization = true
      elsif cmd.opcode == "JLT" && !constants[cmd.reg_r].nil?
        if constants[cmd.reg_r] < 0
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to LDA"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 7, cmd.d, cmd.reg_s)
        else
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to no-op"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 0, 0, 0)
        end
        made_optimization = true
      elsif cmd.opcode == "JGT" && !constants[cmd.reg_r].nil?
        if constants[cmd.reg_r] > 0
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to LDA"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 7, cmd.d, cmd.reg_s)
        else
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to no-op"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 0, 0, 0)
        end
        made_optimization = true
      elsif cmd.opcode == "JLE" && !constants[cmd.reg_r].nil?
        if constants[cmd.reg_r] <= 0
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to LDA"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 7, cmd.d, cmd.reg_s)
        else
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to no-op"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 0, 0, 0)
        end
        made_optimization = true
      elsif cmd.opcode == "JGE" && !constants[cmd.reg_r].nil?
        if constants[cmd.reg_r] >= 0
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to LDA"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 7, cmd.d, cmd.reg_s)
        else
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to no-op"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 0, 0, 0)
        end
        made_optimization = true
      elsif cmd.opcode == "JNE" && !constants[cmd.reg_r].nil?
        if constants[cmd.reg_r] != 0
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to LDA"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 7, cmd.d, cmd.reg_s)
        else
          puts "* Changing " + cmd.opcode + " on line " + cmd.line.to_s + " to no-op"
          bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 0, 0, 0)
        end
        made_optimization = true
      end
      
      # clear constant if register is redefined
      constants[cmd.reg_r] = nil if cmd.defines_register
    end
  end
end

print "\n"
puts "Scanning for dead code"

for bb in tmo.bblocks
  for n in 0..(bb.cmds.length-1)
    cmd = bb.cmds[n]
    
    if cmd.defines_register

      if (cmd.opcode == "LDA" && cmd.reg_r == 7 && cmd.reg_s == 0 && cmd.d == (cmd.line + 1)) ||
         (cmd.opcode == "LDA" && cmd.reg_r == 7 && cmd.reg_s == 7 && cmd.d == 0) ||
         (cmd.opcode == "LDC" && cmd.reg_r == 7 && cmd.d == (cmd.line + 1))
        puts "* Changing dead code at line " + cmd.line.to_s + " to a no-op"
        bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 0, 0, 0) 
        next
      end
      
      next if cmd.reg_r == 7

      # skip this instruction if it is live going OUT of the block
      next if bb.out.include?(cmd.reg_r)

      register_used = false
      for m in (n+1)..(bb.cmds.length-1)
        cmd2 = bb.cmds[m]

        if cmd2.uses_registers.include?(cmd.reg_r)
          register_used = true
          break
        end
        
        # stop searching once the register is redefined
        break if cmd2.defines_register && cmd2.reg_r == cmd.reg_r
      end
      
      if !register_used
        puts "* Changing dead code at line " + cmd.line.to_s + " to a no-op"
        bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 0, 0, 0) 
      end
    end
  end
end

# Look for unreachable blocks
print "\n"
puts "Scanning for unreachable blocks"
for bb in tmo.bblocks
  if !bb.reachable
    print "* Block #" + bb.id.to_s + " line(s) " + bb.cmds[0].line.to_s
    print "-" + bb.cmds.last.line.to_s if bb.cmds.length > 1
    print " is unreachable\n"
    
    # replace all the instructions in this basic block with no-ops
    for n in 0..(bb.cmds.length-1)
      bb.cmds[n] = Tmo::RMInstr.new(bb.cmds[n].line, "LDA", 0, 0, 0) 
    end
  end
end

print "\n"
puts "Removing dead code"

made_optimization = true
while (made_optimization)
  made_optimization = false

for b in 0..(tmo.bblocks.length - 1)
  bb = tmo.bblocks[b]
  for c in 0..(bb.cmds.length - 1)
    cmd = bb.cmds[c]
    if (cmd.opcode == "LDA" && cmd.reg_r == 0 && cmd.d == 0 && cmd.reg_s == 0)
      puts "* Deleting dead code at line " + cmd.line.to_s
      bb.cmds.delete_at(c)
      made_optimization = true
      # adjust all the remaining instructions
      for b2 in 0..(tmo.bblocks.length - 1)
        bb2 = tmo.bblocks[b2]
        for c2 in 0..(bb2.cmds.length - 1)
          cmd2 = bb2.cmds[c2]

          if cmd2.is_jump
            jump_to_line = cmd2.jumps_to

            # adjust instructions that jumped over the deleted instruction
            if (cmd2.line < cmd.line  && jump_to_line > cmd.line)
#              puts "    Adjusting jump at line " + cmd2.line.to_s
              cmd2.d -= 1
            elsif (cmd2.line > cmd.line && jump_to_line < cmd.line && cmd2.reg_s == 7)
#              puts "    Adjusting jump at line " + cmd2.line.to_s
              cmd2.d += 1
            elsif (cmd2.line > cmd.line && jump_to_line > cmd.line && cmd2.reg_s != 7)
#              puts "    Adjusting jump at line " + cmd2.line.to_s
              cmd2.d -= 1
            end
          end

          # adjust line numbers coming after the deleted line
          if cmd2.line > cmd.line
            cmd2.line -= 1
          end

        end
      end
      break
    end
  end
end
end

print "\n"
puts "Consolidating back into 1 block"

Tmo::BasicBlock.start_over
newbb = Tmo::BasicBlock.new
newbb.reachable = true
for bb in tmo.bblocks
  for cmd in bb.cmds
    newbb.cmds << cmd
  end
end

tmo.bblocks = Array.new
tmo.bblocks[0] = newbb

if tmo.bblocks[0].cmds.length < num_instructions
  keep_optimizing = true
else
  keep_optimizing = false
end

main_pass += 1

end

if !output.nil?
  # Output code
  for bb in tmo.bblocks
    for cmd in bb.cmds
      output.write cmd.to_s + "\n"
    end
  end

  output.close
end

exit 0
