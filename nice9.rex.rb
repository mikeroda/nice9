#
# nice9.rex.rb - File partially generated by rex from nice9.rex, and then modified heavily.
# 
# Author: Mike Roda

require 'racc/parser'
#
# nice9.rex
# lexical scanner definition for rex
#

class Nice9 < Racc::Parser
  require 'strscan'

  class ScanError < StandardError ; end

  attr_reader :lineno
  attr_reader :token
 
  def initialize
    super
    @lineno  =  1
  end

  def load_file( filename )
    str = nil
    open(filename, "r") do |f|
      str = f.read
    end
    @ss = StringScanner.new(str)
  end

  def read_stdin
    str = STDIN.read
    @ss = StringScanner.new(str)
  end

  def action &block
    yield
  end

  def parse
    do_parse
  end

  def next_token
    token_pair = nil
    text = nil
    
    until @ss.eos?
      text = @ss.peek(1)
      @lineno  +=  1  if text == "\n"
        case
        when (text = @ss.scan(/[\ \t\r\f\v]+/))
          ;

        when (text = @ss.scan(/\n/))
          ;

        when (text = @ss.scan(/\#[^\n]*\n/))
          @lineno += 1

        when (text = @ss.scan(/[A-Za-z][A-Za-z0-9_]*/))
           case text
             when "read"
               token_pair = action { [:TK_READ, text] }
             when "write"
               token_pair = action { [:TK_WRITE, text] }
             when "writes"
               token_pair = action { [:TK_WRITES, text] }
             when "if"
               token_pair = action { [:TK_IF, text] }
             when "elseif"
               token_pair = action { [:TK_ELSEIF, text] }
             when "then"
               token_pair = action { [:TK_THEN, text] }
             when "else"
               token_pair = action { [:TK_ELSE, text] }
             when "while"
               token_pair = action { [:TK_WHILE, text] }
             when "for"
               token_pair = action { [:TK_FOR, text] }
             when "to"
               token_pair = action { [:TK_TO, text] }
             when "proc"
               token_pair = action { [:TK_PROC, text] }
             when "end"
               token_pair = action { [:TK_END, text] }
             when "return"
               token_pair = action { [:TK_RETURN, text] }
             when "forward"
               token_pair = action { [:TK_FORWARD, text] }
             when "var"
               token_pair = action { [:TK_VAR, text] }
             when "type"
               token_pair = action { [:TK_TYPE, text] }
             when "break"
               token_pair = action { [:TK_BREAK, text] }
             when "exit"
               token_pair = action { [:TK_EXIT, text] }
             when "true"
               token_pair = action { [:TK_TRUE, text] }
             when "false"
               token_pair = action { [:TK_FALSE, text] }

             else
               token_pair = action { [:TK_ID, text] }
           end
        
        when (text = @ss.scan(/\-\>/))
           token_pair = action { [:TK_ARROW, text] }

        when (text = @ss.scan(/\(/))
           token_pair = action { [:TK_LPAREN, text] }

        when (text = @ss.scan(/\)/))
           token_pair = action { [:TK_RPAREN, text] }

        when (text = @ss.scan(/\[/))
           token_pair = action { [:TK_LBRACK, text] }

        when (text = @ss.scan(/\]/))
           token_pair = action { [:TK_RBRACK, text] }

        when (text = @ss.scan(/\:\=/))
           token_pair = action { [:TK_ASSIGN, text] }

        when (text = @ss.scan(/\:/))
           token_pair = action { [:TK_COLON, text] }

        when (text = @ss.scan(/\;/))
           token_pair = action { [:TK_SEMI, text] }

        when (text = @ss.scan(/\?/))
           token_pair = action { [:TK_QUEST, text] }

        when (text = @ss.scan(/\,/))
           token_pair = action { [:TK_COMMA, text] }

        when (text = @ss.scan(/\+/))
           token_pair = action { [:TK_PLUS, text] }

        when (text = @ss.scan(/\-/))
           token_pair = action { [:TK_MINUS, text] }

        when (text = @ss.scan(/\*/))
           token_pair = action { [:TK_STAR, text] }

        when (text = @ss.scan(/\//))
           token_pair = action { [:TK_SLASH, text] }

        when (text = @ss.scan(/\%/))
           token_pair = action { [:TK_MOD, text] }

        when (text = @ss.scan(/\=/))
           token_pair = action { [:TK_EQ, text] }

        when (text = @ss.scan(/\!\=/))
           token_pair = action { [:TK_NEQ, text] }

        when (text = @ss.scan(/\>\=/))
           token_pair = action { [:TK_GE, text] }

        when (text = @ss.scan(/\<\=/))
           token_pair = action { [:TK_LE, text] }

        when (text = @ss.scan(/\>/))
           token_pair = action { [:TK_GT, text] }

        when (text = @ss.scan(/\</))
           token_pair = action { [:TK_LT, text] }

        when (text = @ss.scan(/[0-9]+/))
           token_pair = action { [:TK_INT, text.to_i] }

        when (text = @ss.scan(/'[^'\n]*'/))
           token_pair = action { [:TK_SLIT, text] }

        when (text = @ss.scan(/"[^"\n]*"/))
           token_pair = action { [:TK_SLIT, text] }

        else
          text = @ss.getch
          @token = text
          raise  ScanError, "can not match: '" + text + "'"
        end  # if

        if !token_pair.nil?
          break
        end
    end  # until @ss
    
    @token = text if !text.nil?
    
#   puts token_pair
    token_pair
  end  # def next_token

end
